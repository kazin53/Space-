<!DOCTYPE html>
<html>
<head>
    <title>Guarda-Chuvas Evolutivo PRO</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            /* Fundo principal do BODY ser√° o gradiente radial da tela inicial */
            background: radial-gradient(circle, rgba(100,200,255,0.8), rgba(0,100,200,0.9));
            touch-action: manipulation; /* Melhora a resposta ao toque */
            -webkit-tap-highlight-color: transparent; /* Remove o destaque de toque */
            user-select: none; /* Desabilita sele√ß√£o de texto */
            display: flex; /* Para centralizar a splash screen */
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
        }
        canvas {
            /* O canvas agora estar√° sempre vis√≠vel quando o jogo estiver ativo, mas o fundo √© do body */
            display: none; /* Escondido inicialmente */
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 100;
            display: flex;
            gap: 20px;
        }
        #level-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 100;
            text-align: right;
        }
        #game-over, #game-win, #pause-screen, #settings-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            color: white;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
            opacity: 0; /* Para transi√ß√£o suave */
            transition: opacity 0.5s ease-in-out;
        }
        #game-over.active, #game-win.active, #pause-screen.active, #settings-screen.active {
            opacity: 1;
        }
        #game-over h1, #game-win h1, #pause-screen h1, #settings-screen h1 {
            font-size: 3em;
            margin-bottom: 20px;
        }
        #game-over h1 { color: #FF5252; }
        #game-win h1 { color: #4CAF50; text-shadow: 2px 2px 10px rgba(0, 255, 0, 0.7); animation: win-pulse 1.5s infinite; }
        @keyframes win-pulse { 0% { transform: scale(1); } 50% { transform: scale(1.08); } 100% { transform: scale(1); } }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
        #restart-btn, #play-again-win-btn, #pause-btn, #resume-btn, .game-button, #settings-back-btn, #back-to-start-btn {
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 1.5em;
            background: linear-gradient(45deg, #FF5252, #FF9800);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s;
            text-decoration: none;
        }
        .game-button:hover, #settings-back-btn:hover, #back-to-start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }
        #pause-btn {
            position: absolute;
            top: 20px;
            left: calc(50% - 75px);
            padding: 10px 20px;
            font-size: 1.2em;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            z-index: 100;
        }
        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Fundo da tela inicial, permanece o mesmo */
            background: radial-gradient(circle, rgba(100,200,255,0.8), rgba(0,100,200,0.9));
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0; /* Para transi√ß√£o suave */
            transition: opacity 0.5s ease-in-out;
        }
        #start-screen.active {
            opacity: 1;
        }
        #start-title {
            font-size: 3rem;
            color: white;
            text-shadow: 3px 3px 5px rgba(0, 0, 0, 0.5);
            margin-bottom: 30px;
            animation: pulse 2s infinite;
        }
        .start-button {
            background: linear-gradient(45deg, #FF5252, #FF9800);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.5rem;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s;
            margin: 10px;
            text-decoration: none;
            display: inline-block;
        }
        .start-button:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }

        /* Estilos da Tela de Configura√ß√µes */
        .settings-option {
            margin-bottom: 25px;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 80%;
            max-width: 400px;
        }
        .settings-option label {
            font-size: 1.3em;
            margin-bottom: 10px;
            color: #FFF;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .color-palettes {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .color-swatch {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 3px solid rgba(255,255,255,0.7);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .color-swatch:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(255,255,255,0.8);
        }
        .color-swatch.selected {
            border: 3px solid #4CAF50;
            box-shadow: 0 0 10px #4CAF50;
            transform: scale(1.15);
        }
        input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 10px;
            background: #d3d3d3;
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
            border-radius: 5px;
            margin-top: 10px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        input[type="range"]::-moz-range-thumb {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        #sensitivity-value {
            font-size: 1.1em;
            margin-top: 5px;
        }
        .pause-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        /* SPLASH SCREEN */
        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(100,200,255,0.8), rgba(0,100,200,0.9));
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            color: white;
            font-size: 2em;
            text-shadow: 2px 2px 5px rgba(0,0,0,0.5);
            transition: opacity 1s ease-out;
            opacity: 1;
        }
        #splash-screen.hidden {
            opacity: 0;
            pointer-events: none; /* Desabilita cliques ap√≥s desaparecer */
        }
        #splash-screen img {
            width: 100px; /* Tamanho do √≠cone de carregamento */
            height: 100px;
            animation: spin 1.5s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="splash-screen">
        <img src="https://em-content.zobj.net/source/apple/354/umbrella_2602-fe0f.png" alt="Carregando..."> <p>Carregando Jogo...</p>
    </div>

    <div id="ui">
        ‚òÇÔ∏è <span id="score">0</span> | ‚ù§Ô∏è <span id="lives">5</span> | üèÜ <span id="highscore">0</span>
    </div>
    <div id="level-indicator">N√≠vel: C√©u<br>Pr√≥ximo: 1000 pontos</div>
    <button id="pause-btn">Pausar</button>
    <canvas id="gameCanvas"></canvas>

    <div id="start-screen">
        <h1 id="start-title">Guarda-Chuvas Evolutivo</h1>
        <button class="start-button" id="start-button">Jogar</button>
        <button class="start-button" id="settings-button">‚öôÔ∏è Configura√ß√µes</button>
        <a href="https://kusuncod.github.io/CadzinB/" target="_blank" class="start-button">Visite meu Site!</a>
    </div>

    <div id="game-over">
        <h1>FIM DE JOGO</h1>
        <p id="final-score">Pontua√ß√£o: 0</p>
        <p id="final-level">N√≠vel alcan√ßado: C√©u</p>
        <button id="restart-btn">Jogar Novamente</button>
    </div>

    <div id="game-win">
        <h1>PARAB√âNS! VOC√ä VENCEU!</h1>
        <p id="final-score-win">Pontua√ß√£o Final: 0</p>
        <button id="play-again-win-btn">Jogar Novamente</button>
    </div>

    <div id="pause-screen">
        <h1>PAUSADO</h1>
        <div class="pause-buttons">
            <button id="resume-btn">Continuar Jogo</button>
            <button id="back-to-start-btn" class="game-button">Tela Inicial</button>
        </div>
    </div>

    <div id="settings-screen">
        <h1>‚öôÔ∏è Configura√ß√µes</h1>

        <div class="settings-option">
            <label for="background-color-selector">Cor de Fundo Padr√£o (afeta o in√≠cio e transi√ß√µes):</label>
            <div class="color-palettes">
                <div class="color-swatch selected" data-color="default" style="background: linear-gradient(to bottom, #87CEEB, #B0E0E6);"></div>
                <div class="color-swatch" data-color="dark" style="background: linear-gradient(to bottom, #2c3e50, #34495e);"></div>
                <div class="color-swatch" data-color="sunset" style="background: linear-gradient(to bottom, #fdc830, #f37335);"></div>
                <div class="color-swatch" data-color="forest" style="background: linear-gradient(to bottom, #4CAF50, #8BC34A);"></div>
            </div>
        </div>

        <div class="settings-option">
            <label for="touch-sensitivity">Sensibilidade ao Toque:</label>
            <input type="range" id="touch-sensitivity" min="0.5" max="2.0" step="0.1" value="1.0">
            <span id="sensitivity-value">1.0</span>
        </div>

        <button id="settings-back-btn" class="game-button">Voltar</button>
    </div>

    <script>
        // ===== CONFIGURA√á√ïES GERAIS =====
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const livesElement = document.getElementById('lives');
        const levelElement = document.getElementById('level-indicator');
        const uiElement = document.getElementById('ui');
        const highscoreElement = document.getElementById('highscore');

        // Elementos da Tela Inicial e Configura√ß√µes
        const splashScreen = document.getElementById('splash-screen'); // NOVO: Splash Screen
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const settingsButton = document.getElementById('settings-button');
        const settingsScreen = document.getElementById('settings-screen');
        const settingsBackBtn = document.getElementById('settings-back-btn');
        const colorSwatches = document.querySelectorAll('.color-swatch');
        const touchSensitivitySlider = document.getElementById('touch-sensitivity');
        const sensitivityValueSpan = document.getElementById('sensitivity-value');

        const gameOverScreen = document.getElementById('game-over');
        const gameWinScreen = document.getElementById('game-win');
        const pauseScreen = document.getElementById('pause-screen');
        const finalScoreElement = document.getElementById('final-score');
        const finalLevelElement = document.getElementById('final-level');
        const finalScoreWinElement = document.getElementById('final-score-win');
        const restartBtn = document.getElementById('restart-btn');
        const playAgainWinBtn = document.getElementById('play-again-win-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const resumeBtn = document.getElementById('resume-btn');
        const backToStartBtn = document.getElementById('back-to-start-btn');

        // Vari√°veis de estado do jogo
        let score = 0;
        let lives = 5;
        let currentLevelIndex = 0;
        let transitionActive = false;
        let transitionProgress = 0;
        let highscore = localStorage.getItem('highscore') || 0;
        let lastTime = 0;
        const targetFps = 60; // NOVO: FPS alvo para o jogo
        const frameInterval = 1000 / targetFps; // NOVO: Intervalo de tempo entre cada frame
        let gameActive = false; // Come√ßa como false para exibir a tela inicial
        let isPaused = false;
        let gameLoopRAF; // Renomeado para usar requestAnimationFrame
        let floatingTexts = [];

        // Vari√°veis de Configura√ß√£o
        let touchSensitivity = parseFloat(localStorage.getItem('touchSensitivity')) || 1.0;
        let currentBackgroundPreset = localStorage.getItem('backgroundPreset') || 'default';

        // Efeitos sonoros
        // NOVO: Pool de √°udio para sons de pop (evita atrasos)
        const soundPool = {
            pop: [],
            poolSize: 10,
            init: function() {
                for (let i = 0; i < this.poolSize; i++) {
                    const audio = new Audio('https://assets.mixkit.co/sfx/preview/mixkit-game-balloon-pop-1003.mp3');
                    audio.volume = 0.7; // Ajuste de volume
                    this.pop.push(audio);
                }
            },
            playPop: function() {
                for (let i = 0; i < this.poolSize; i++) {
                    if (this.pop[i].paused || this.pop[i].ended) {
                        this.pop[i].currentTime = 0;
                        this.pop[i].play().catch(e => console.log("Erro ao tocar pop sound:", e));
                        return;
                    }
                }
            }
        };
        soundPool.init(); // Inicializa o pool de sons

        // Sons √∫nicos
        const sounds = {
            loseLife: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-losing-top-score-2029.mp3'),
            transition: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-sci-fi-positive-interface-902.mp3'),
            gameOver: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-retro-arcade-lose-2027.mp3'),
            gameWin: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-achievement-bell-600.mp3'),
            backgroundMusic: new Audio('./musica.mp3'), // Arquivo local na mesma pasta
            uiClick: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-game-click-1111.mp3') // NOVO: Som para cliques na UI
        };

        sounds.backgroundMusic.loop = true;
        sounds.backgroundMusic.volume = 0.5;
        sounds.uiClick.volume = 0.5;

        // Ajuste de tela
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Reinicializa elementos de fundo que dependem do tamanho do canvas
            if (gameActive && !isPaused) {
                initializeLevelElements();
            }
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // NOVO: Efeito de Vignette (escurece as bordas da tela)
        function drawVignette() {
            const gradient = ctx.createRadialGradient(
                canvas.width / 2,
                canvas.height / 2,
                Math.min(canvas.width, canvas.height) * 0.3,
                canvas.width / 2,
                canvas.height / 2,
                Math.min(canvas.width, canvas.height) * 0.8
            );
            gradient.addColorStop(0, 'rgba(0,0,0,0)');
            gradient.addColorStop(1, 'rgba(0,0,0,0.4)'); // 40% de opacidade na borda
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // NOVO: Haptic Feedback (vibra√ß√£o para celulares)
        function vibratePhone(duration = 50) {
            if (navigator.vibrate) {
                navigator.vibrate(duration);
            }
        }

        // ===== SISTEMA DE N√çVEIS =====
        const levels = [
            {
                name: "C√©u",
                umbrellaColors: ['#FF5252', '#4285F4', '#FBBC05', '#34A853'],
                spawnRate: 0.015,
                baseSpeed: 2,
                scoreValue: 20,
                nextLevelScore: 1000
            },
            {
                name: "Deserto",
                umbrellaColors: ['#A0522D', '#D2B48C', '#F4A460', '#BDB76B'],
                spawnRate: 0.02,
                baseSpeed: 3,
                scoreValue: 50,
                nextLevelScore: 5000
            },
            {
                name: "Oceano",
                umbrellaColors: ['#00BFFF', '#1E90FF', '#4169E1', '#4682B4'],
                spawnRate: 0.025,
                baseSpeed: 4,
                scoreValue: 100,
                nextLevelScore: 20000
            },
            {
                name: "Gelo",
                umbrellaColors: ['#FFFFFF', '#ADD8E6', '#87CEEB', '#B0E0E6'],
                spawnRate: 0.03,
                baseSpeed: 5,
                scoreValue: 120,
                nextLevelScore: 40000
            },
            {
                name: "Espa√ßo",
                umbrellaColors: ['#ff00ff', '#00ffff', '#ffff00', '#ff00ff'],
                spawnRate: 0.035,
                baseSpeed: 6,
                scoreValue: 150, // Aumentado valor do score
                nextLevelScore: 100000 // Pontua√ß√£o final para zerar
            }
        ];

        // Defini√ß√£o das cores de fundo para as configura√ß√µes (estas s√£o para as telas de menu)
        const backgroundPresets = {
            'default': "linear-gradient(to bottom, #87CEEB, #B0E0E6)",
            'dark': "linear-gradient(to bottom, #2c3e50, #34495e)",
            'sunset': "linear-gradient(to bottom, #fdc830, #f37335)",
            'forest': "linear-gradient(to bottom, #4CAF50, #8BC34A)"
        };

        // A fun√ß√£o applyGameBackground n√£o precisar√° mais mudar o background do body,
        // apenas garante que o canvas esteja vis√≠vel e o body tenha o fundo padr√£o.
        function applyGameBackground() {
            // O fundo do body j√° est√° definido no CSS, n√£o precisa ser mudado aqui
            // document.body.style.background = levels[currentLevelIndex].background; // REMOVIDO
            // Garante que a UI tenha o text-shadow correto (se necess√°rio, baseado no "n√≠vel")
             const currentLevelData = levels[currentLevelIndex];
             if (currentLevelData.name.includes('Espa√ßo')) {
                 uiElement.style.textShadow = '0 0 10px #00ffff, 0 0 20px #ff00ff';
            } else if (currentLevelData.name.includes('Deserto')) {
                uiElement.style.textShadow = '2px 2px 4px rgba(0,0,0,0.7)';
            } else if (currentLevelData.name.includes('Oceano') || currentLevelData.name.includes('Gelo')) {
                uiElement.style.textShadow = '2px 2px 4px rgba(0,0,0,0.5)';
            } else { // Padr√£o para C√©u e outros
                uiElement.style.textShadow = '2px 2px 4px rgba(0,0,0,0.5)';
            }
        }

        function applyMenuBackground() {
            // Esta fun√ß√£o ainda √© √∫til para definir o fundo das telas de menu/pausa/game over
            document.body.style.background = backgroundPresets[currentBackgroundPreset] || backgroundPresets['default'];
        }

        function checkLevelTransition() {
            const currentLevelData = levels[currentLevelIndex];
            // Verifica se atingiu a meta para o pr√≥ximo n√≠vel e n√£o √© o √∫ltimo
            if (score >= currentLevelData.nextLevelScore && currentLevelIndex < levels.length - 1 && !transitionActive) {
                startTransition(currentLevelIndex + 1); // Passa o √≠ndice do pr√≥ximo n√≠vel
            }
            // Verifica a condi√ß√£o de vit√≥ria: atingir a pontua√ß√£o final no √∫ltimo n√≠vel (Espa√ßo)
            else if (score >= currentLevelData.nextLevelScore && currentLevelIndex === levels.length - 1 && !transitionActive) {
                endGame(true); // Termina o jogo com vit√≥ria
            }
        }

        function startTransition(newLevelIndex) {
            transitionActive = true;
            gameActive = false; // Pausa o jogo durante a transi√ß√£o
            cancelAnimationFrame(gameLoopRAF); // NOVO: Para o RAF durante a transi√ß√£o
            const newLevelData = levels[newLevelIndex];

            levelElement.innerHTML = `Transi√ß√£o para o ${newLevelData.name}!`;

            // Ajusta o text-shadow da UI para combinar com o novo tema
            if (newLevelData.name.includes('Espa√ßo')) {
                 uiElement.style.textShadow = '0 0 10px #00ffff, 0 0 20px #ff00ff';
            } else if (newLevelData.name.includes('Deserto')) {
                uiElement.style.textShadow = '2px 2px 4px rgba(0,0,0,0.7)';
            } else if (newLevelData.name.includes('Oceano') || newLevelData.name.includes('Gelo')) {
                uiElement.style.textShadow = '2px 2px 4px rgba(0,0,0,0.5)';
            } else { // Padr√£o para C√©u
                uiElement.style.textShadow = '2px 2px 4px rgba(0,0,0,0.5)';
            }

            sounds.transition.play();
            // A transi√ß√£o √© mais visual agora, o jogo retorna ap√≥s um pequeno delay
            setTimeout(() => {
                completeTransition(newLevelIndex);
                gameLoopRAF = requestAnimationFrame(gameLoop); // NOVO: Reinicia o RAF
            }, 2000); // 2 segundos de transi√ß√£o
        }

        function completeTransition(newLevelIndex) {
            currentLevelIndex = newLevelIndex;
            transitionActive = false;
            transitionProgress = 0;
            gameActive = true; // Retoma o jogo

            const currentLevelData = levels[currentLevelIndex];
            levelElement.innerHTML = `N√≠vel: ${currentLevelData.name}<br>Pr√≥ximo: ${currentLevelData.nextLevelScore} pontos`;

            // Limpa todos os guarda-chuvas e elementos de fundo do n√≠vel anterior
            currentUmbrellas = [];
            currentParticles = [];
            floatingTexts = []; // Limpa textos flutuantes
            clouds = [];
            cacti = [];
            dunes = [];
            stars = [];
            nebulas = [];
            icebergs = [];
            snowflakes = [];
            waterBubbles = [];

            // Inicializa elementos espec√≠ficos do novo n√≠vel
            initializeLevelElements();
        }

        // ===== ELEMENTOS DOS N√çVEIS (Guarda-Chuvas e Backgrounds) =====
        let currentUmbrellas = []; // Array unificado para guarda-chuvas
        let currentParticles = []; // Array unificado para part√≠culas (explos√£o)

        // Elementos de fundo por n√≠vel (vari√°veis globais)
        let clouds = []; // Para o n√≠vel C√©u
        let cacti = []; // Para o n√≠vel Deserto
        let dunes = []; // Para o n√≠vel Deserto
        let stars = []; // Para o n√≠vel Espa√ßo
        let nebulas = []; // Para o n√≠vel Espa√ßo
        let icebergs = []; // Para o n√≠vel Gelo
        let snowflakes = []; // Para o n√≠vel Gelo
        let waterBubbles = []; // Para o n√≠vel Oceano

        function initializeLevelElements() {
            // Sempre limpamos tudo para evitar "vazamento" de elementos de n√≠veis anteriores
            clouds = [];
            cacti = [];
            dunes = [];
            stars = [];
            nebulas = [];
            icebergs = [];
            snowflakes = [];
            waterBubbles = [];

            const levelData = levels[currentLevelIndex];
            if (levelData.name.includes('C√©u')) {
                clouds = Array.from({ length: 5 }, () => ({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height * 0.4, // Mais alto no c√©u
                    speed: 0.2 + Math.random() * 0.3,
                    size: 50 + Math.random() * 70,
                    opacity: 0.7 + Math.random() * 0.3
                }));
            } else if (levelData.name.includes('Deserto')) {
                cacti = Array.from({ length: 10 }, () => ({
                    x: Math.random() * canvas.width,
                    y: canvas.height - (30 + Math.random() * 70), // No ch√£o
                    height: 30 + Math.random() * 70
                }));
                dunes = Array.from({ length: 3 }, () => ({
                    x: Math.random() * canvas.width,
                    y: canvas.height - (30 + Math.random() * 50),
                    width: 150 + Math.random() * 200,
                    height: 30 + Math.random() * 50,
                    color: `rgba(${255 - Math.random() * 50}, ${215 - Math.random() * 50}, ${0}, 0.8)`
                }));
            } else if (levelData.name.includes('Oceano')) {
                waterBubbles = Array.from({ length: 30 }, () => ({
                    x: Math.random() * canvas.width,
                    y: canvas.height + Math.random() * 100,
                    size: 5 + Math.random() * 15,
                    speed: 1 + Math.random() * 2,
                    opacity: 0.4 + Math.random() * 0.6
                }));
            } else if (levelData.name.includes('Gelo')) {
                icebergs = Array.from({ length: 5 }, () => ({
                    x: Math.random() * canvas.width,
                    y: canvas.height * 0.8 + Math.random() * canvas.height * 0.2, // Perto do fundo
                    size: 80 + Math.random() * 100,
                    opacity: 0.6 + Math.random() * 0.4
                }));
                snowflakes = Array.from({ length: 50 }, () => ({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: 2 + Math.random() * 3,
                    speedY: 0.5 + Math.random() * 1,
                    speedX: (Math.random() - 0.5) * 0.5,
                    opacity: 0.6 + Math.random() * 0.4
                }));
            } else if (levelData.name.includes('Espa√ßo')) {
                stars = Array.from({ length: 200 }, () => ({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2,
                    opacity: Math.random(),
                    speed: Math.random() * 0.2
                }));
                nebulas = Array.from({ length: 3 }, () => ({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height * 0.5,
                    radius: 100 + Math.random() * 200,
                    color: `hsla(${Math.random() * 360}, 80%, 60%, 0.1)`,
                    speed: Math.random() * 0.1 - 0.05
                }));
            }
        }

        // Fun√ß√£o para criar guarda-chuva (gen√©rica para todos os n√≠veis)
        function createUmbrella() {
            const levelData = levels[currentLevelIndex];
            const color = levelData.umbrellaColors[Math.floor(Math.random() * levelData.umbrellaColors.length)];
            const speed = levelData.baseSpeed + (score / 20000); // Velocidade aumenta com a pontua√ß√£o global

            currentUmbrellas.push({
                x: Math.random() * (canvas.width - 100), // Ajustado para novo tamanho
                y: -120, // Ajustado para novo tamanho
                speed: speed,
                color: color,
                width: 100, // Novo tamanho (anteriormente 80)
                height: 120, // Novo tamanho (anteriormente 100)
            });
        }

        // Desenho do guarda-chuva (design aprimorado)
        function drawUmbrella(u) {
            const centerX = u.x + u.width / 2;
            const canopyTopY = u.y;
            const canopyBottomY = u.y + u.height * 0.5; // Altura da c√∫pula
            const handleStartY = canopyBottomY - 10; // Onde o cabo come√ßa abaixo da c√∫pula
            const handleLength = u.height * 0.5; // Comprimento do cabo
            const handleThickness = 5;
            const handleColor = '#654321'; // Marrom para o cabo
            const tipRadius = 8; // Raio da ponta da al√ßa

            // Cabo reto (haste principal)
            ctx.fillStyle = handleColor;
            ctx.fillRect(centerX - handleThickness / 2, handleStartY, handleThickness, handleLength);

            // Al√ßa curva (parte de baixo)
            ctx.beginPath();
            ctx.arc(centerX + tipRadius, handleStartY + handleLength, tipRadius, Math.PI, Math.PI * 1.5, false); // Canto superior esquerdo
            ctx.lineTo(centerX - tipRadius, handleStartY + handleLength + tipRadius); // Linha para baixo
            ctx.arc(centerX - tipRadius, handleStartY + handleLength, tipRadius, Math.PI * 1.5, Math.PI * 2, false); // Canto superior direito
            ctx.fill();

            // Desenhar a c√∫pula do guarda-chuva em gomos
            const segments = 8; // N√∫mero de gomos
            const radius = u.width / 2; // Raio da c√∫pula

            ctx.lineWidth = 2; // Espessura das linhas dos gomos
            const strokeColor = darkenColor(u.color, 40); // Cor das linhas dos gomos

            // Desenha a parte superior (vis√≠vel quando aberto)
            for (let i = 0; i < segments; i++) {
                ctx.beginPath();
                ctx.moveTo(centerX, canopyTopY); // Topo do guarda-chuva

                // Pontos na base da c√∫pula para formar os gomos
                const angle1 = (i / segments) * Math.PI; // Meia circunfer√™ncia para a base
                const angle2 = ((i + 1) / segments) * Math.PI;

                const x1 = centerX - radius * Math.cos(angle1); // Usar cos para espalhar horiz.
                const y1 = canopyBottomY;
                const x2 = centerX - radius * Math.cos(angle2);
                const y2 = canopyBottomY;

                ctx.lineTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.closePath();
                ctx.fillStyle = u.color;
                ctx.fill();
                ctx.strokeStyle = strokeColor;
                ctx.stroke();
            }

            // Desenha a ponta central do guarda-chuva
            ctx.fillStyle = darkenColor(u.color, 60);
            ctx.beginPath();
            ctx.arc(centerX, canopyTopY, 5, 0, Math.PI * 2);
            ctx.fill();
        }


        // Fun√ß√£o auxiliar para escurecer uma cor (para o design do guarda-chuva)
        function darkenColor(hex, percent) {
            if (!hex || hex.length < 7) return '#000000'; // Fallback
            const f = parseInt(hex.slice(1), 16);
            const R = (f >> 16) * (1 - percent / 100);
            const G = ((f >> 8) & 0x00FF) * (1 - percent / 100);
            const B = (f & 0x0000FF) * (1 - percent / 100);
            return "#" + (0x1000000 + (R << 16) + (G << 8) + B).toString(16).slice(1);
        }

        // Fun√ß√µes de desenho de elementos de fundo espec√≠ficas
        function drawCloud(x, y, size, opacity) {
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.beginPath();
            ctx.arc(x, y, size * 0.6, 0, Math.PI * 2);
            ctx.arc(x + size * 0.4, y - size * 0.2, size * 0.4, 0, Math.PI * 2);
            ctx.arc(x + size * 0.8, y, size * 0.5, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawCactus(x, y, height) {
            ctx.fillStyle = '#228B22'; // Verde escuro
            ctx.fillRect(x, y, 15, height); // Tronco principal
            // Bra√ßos do cacto
            ctx.fillRect(x - 10, y + height * 0.3, 15, height * 0.2);
            ctx.fillRect(x + 10, y + height * 0.6, 15, height * 0.2);
        }

        function drawDune(x, y, width, height, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x + width / 2, y + height, width / 2, 0, Math.PI, true); // Topo da duna
            ctx.lineTo(x, y + height);
            ctx.lineTo(x, y + height * 0.5); // Para baixo
            ctx.lineTo(x + width, y + height * 0.5); // Para cima
            ctx.lineTo(x + width, y + height);
            ctx.fill();
        }

        function drawStars() {
            stars.forEach(star => {
                ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
                ctx.fillRect(star.x, star.y, star.size, star.size);
                star.y += star.speed;
                if (star.y > canvas.height) star.y = 0;
            });
        }

        function drawNebulas() {
            nebulas.forEach(nebula => {
                const gradient = ctx.createRadialGradient(
                    nebula.x, nebula.y, 0,
                    nebula.x, nebula.y, nebula.radius
                );
                gradient.addColorStop(0, nebula.color);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(nebula.x, nebula.y, nebula.radius, 0, Math.PI * 2);
                ctx.fill();
                nebula.x += nebula.speed;
                if (nebula.x < -nebula.radius) nebula.x = canvas.width + nebula.radius;
            });
        }

        function drawIceberg(x, y, size, opacity) {
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + size, y);
            ctx.lineTo(x + size * 0.8, y - size * 0.6);
            ctx.lineTo(x + size * 0.2, y - size * 0.8);
            ctx.closePath();
            ctx.fill();
        }

        function drawSnowflake(x, y, size, opacity) {
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawWaterBubbles() {
            waterBubbles.forEach((bubble, i) => {
                ctx.fillStyle = `rgba(173, 216, 230, ${bubble.opacity})`;
                ctx.beginPath();
                ctx.arc(bubble.x, bubble.y, bubble.size, 0, Math.PI * 2);
                ctx.fill();
                bubble.y -= bubble.speed;
                if (bubble.y < -bubble.size) {
                    bubble.y = canvas.height + Math.random() * 100;
                    bubble.x = Math.random() * canvas.width;
                }
                // NOVO: Adicionado um limite para a quantidade de bolhas
                // para evitar sobrecarga em n√≠veis mais avan√ßados
                if (Math.random() > 0.97 && waterBubbles.length < 50) {
                    waterBubbles.push({
                        x: Math.random() * canvas.width,
                        y: canvas.height + Math.random() * 100,
                        size: 5 + Math.random() * 15,
                        speed: 1 + Math.random() * 2,
                        opacity: 0.4 + Math.random() * 0.6
                    });
                }
            });
        }

        // Fun√ß√£o para atualizar e desenhar elementos de fundo por n√≠vel
        function updateAndDrawBackgroundElements() {
            // O fundo principal √© o do body, ent√£o o canvas s√≥ desenha os elementos sobre ele
            const levelData = levels[currentLevelIndex];
            if (levelData.name.includes('C√©u')) {
                clouds.forEach(cloud => {
                    cloud.x += cloud.speed;
                    if (cloud.x > canvas.width + cloud.size) cloud.x = -cloud.size;
                    drawCloud(cloud.x, cloud.y, cloud.size, cloud.opacity);
                });
            } else if (levelData.name.includes('Deserto')) {
                dunes.forEach(dune => {
                    drawDune(dune.x, dune.y, dune.width, dune.height, dune.color);
                });
                cacti.forEach(cactus => {
                    drawCactus(cactus.x, cactus.y, cactus.height);
                });
            } else if (levelData.name.includes('Oceano')) {
                drawWaterBubbles();
            } else if (levelData.name.includes('Gelo')) {
                icebergs.forEach(iceberg => {
                    drawIceberg(iceberg.x, iceberg.y, iceberg.size, iceberg.opacity);
                });
                snowflakes.forEach((flake, i) => {
                    drawSnowflake(flake.x, flake.y, flake.size, flake.opacity);
                    flake.y += flake.speedY;
                    flake.x += flake.speedX;
                    if (flake.y > canvas.height) {
                        flake.y = -flake.size;
                        flake.x = Math.random() * canvas.width;
                    }
                });
            } else if (levelData.name.includes('Espa√ßo')) {
                drawStars();
                drawNebulas();
            }
            drawVignette(); // NOVO: Desenha a vignette por cima de tudo no jogo
        }

        // ===== EFEITO DE TRANSI√á√ÉO =====
        function drawTransition() {
            ctx.fillStyle = `rgba(0, 0, 0, ${transitionProgress})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (transitionProgress < 1) {
                transitionProgress += 0.01;
            } else {
                transitionProgress = 1;
            }
        }

        // ===== GAME OVER, VIT√ìRIA E REIN√çCIO =====
        function endGame(win) {
            gameActive = false;
            isPaused = true; // Garante que o jogo fique pausado na tela final
            if (gameLoopRAF) cancelAnimationFrame(gameLoopRAF); // NOVO: Cancela RAF
            sounds.backgroundMusic.pause();

            if (score > highscore) {
                highscore = score;
                localStorage.setItem('highscore', highscore);
            }
            highscoreElement.textContent = highscore;

            if (win) {
                sounds.gameWin.play();
                finalScoreWinElement.textContent = `Pontua√ß√£o Final: ${score}`;
                gameWinScreen.style.display = 'flex';
                // Adiciona a classe 'active' para a transi√ß√£o de opacidade
                setTimeout(() => gameWinScreen.classList.add('active'), 10);
                pauseBtn.style.display = 'none'; // Esconde o bot√£o de pausa
            } else {
                sounds.gameOver.play();
                finalScoreElement.textContent = `Pontua√ß√£o: ${score}`;
                finalLevelElement.textContent = `N√≠vel alcan√ßado: ${levels[currentLevelIndex].name}`;
                gameOverScreen.style.display = 'flex';
                // Adiciona a classe 'active' para a transi√ß√£o de opacidade
                setTimeout(() => gameOverScreen.classList.add('active'), 10);
                pauseBtn.style.display = 'none'; // Esconde o bot√£o de pausa
            }
            canvas.style.display = 'none'; // Esconde o canvas
            applyMenuBackground(); // Retorna ao fundo de menu (se for diferente)
        }

        function resetGame() {
            score = 0;
            lives = 5;
            currentLevelIndex = 0;
            transitionActive = false;
            transitionProgress = 0;
            gameActive = true;
            isPaused = false;

            currentUmbrellas = [];
            currentParticles = [];
            floatingTexts = []; // Limpa textos flutuantes
            clouds = [];
            cacti = [];
            dunes = [];
            stars = [];
            nebulas = [];
            icebergs = [];
            snowflakes = [];
            waterBubbles = [];

            // Limpa classes 'active' de todas as telas de game over/win/pause
            gameOverScreen.classList.remove('active');
            gameWinScreen.classList.remove('active');
            pauseScreen.classList.remove('active');
            startScreen.classList.remove('active');
            settingsScreen.classList.remove('active');

            // O fundo do body j√° est√° no gradiente radial, n√£o precisamos mudar aqui.
            uiElement.style.textShadow = '2px 2px 4px rgba(0,0,0,0.5)'; // Volta para o padr√£o de c√©u

            scoreElement.textContent = score;
            livesElement.textContent = lives;
            levelElement.innerHTML = `N√≠vel: ${levels[0].name}<br>Pr√≥ximo: ${levels[0].nextLevelScore} pontos`;
            highscoreElement.textContent = highscore;

            gameOverScreen.style.display = 'none';
            gameWinScreen.style.display = 'none';
            pauseScreen.style.display = 'none';
            startScreen.style.display = 'none'; // Esconde a tela inicial
            settingsScreen.style.display = 'none'; // Esconde a tela de configura√ß√µes
            canvas.style.display = 'block'; // Mostra o canvas
            pauseBtn.style.display = 'block'; // Mostra o bot√£o de pausa

            initializeLevelElements();
            sounds.backgroundMusic.currentTime = 0;
            sounds.backgroundMusic.play().catch(e => console.log("Erro ao tocar m√∫sica:", e));

            if (gameLoopRAF) cancelAnimationFrame(gameLoopRAF);
            gameLoopRAF = requestAnimationFrame(gameLoop);
        }

        function returnToStartScreen() {
            gameActive = false;
            isPaused = true;
            if (gameLoopRAF) cancelAnimationFrame(gameLoopRAF); // NOVO: Cancela RAF
            sounds.backgroundMusic.pause();

            // Limpa classes 'active' de todas as telas de game over/win/pause
            gameOverScreen.classList.remove('active');
            gameWinScreen.classList.remove('active');
            pauseScreen.classList.remove('active');
            settingsScreen.classList.remove('active');

            gameOverScreen.style.display = 'none';
            gameWinScreen.style.display = 'none';
            pauseScreen.style.display = 'none';
            canvas.style.display = 'none'; // Esconde o canvas
            pauseBtn.style.display = 'none'; // Esconde o bot√£o de pausa

            startScreen.style.display = 'flex'; // Mostra a tela inicial
            setTimeout(() => startScreen.classList.add('active'), 10); // NOVO: Transi√ß√£o
            applyMenuBackground(); // Aplica o fundo do menu (se for diferente do jogo)
        }

        // ===== PAUSE / UNPAUSE =====
        function togglePause() {
            sounds.uiClick.play().catch(e => console.log("Erro ao tocar UI click:", e)); // NOVO: Som de clique
            isPaused = !isPaused;
            if (isPaused) {
                cancelAnimationFrame(gameLoopRAF); // Para o loop do jogo
                sounds.backgroundMusic.pause(); // Pausa a m√∫sica
                pauseScreen.style.display = 'flex'; // Mostra a tela de pausa
                setTimeout(() => pauseScreen.classList.add('active'), 10); // NOVO: Transi√ß√£o
                pauseBtn.textContent = 'Retomar'; // Muda o texto do bot√£o
                applyMenuBackground(); // Muda o fundo para o do menu
            } else {
                gameLoopRAF = requestAnimationFrame(gameLoop); // Retoma o loop
                sounds.backgroundMusic.play().catch(e => console.log("Erro ao retomar m√∫sica:", e)); // Retoma a m√∫sica
                pauseScreen.classList.remove('active'); // NOVO: Remove transi√ß√£o
                // O display none √© aplicado ap√≥s a transi√ß√£o para garantir que ela ocorra
                pauseScreen.addEventListener('transitionend', function handler() {
                    pauseScreen.style.display = 'none';
                    pauseScreen.removeEventListener('transitionend', handler);
                });
                pauseBtn.textContent = 'Pausar'; // Volta o texto do bot√£o
            }
        }

        // ===== LOOP PRINCIPAL =====
        function gameLoop(timestamp) {
            gameLoopRAF = requestAnimationFrame(gameLoop); // NOVO: Sempre agende o pr√≥ximo frame

            if (!gameActive || isPaused) {
                return; // Se n√£o estiver ativo ou pausado, apenas retorna e espera o pr√≥ximo frame
            }

            const deltaTime = timestamp - lastTime;
            if (deltaTime < frameInterval) {
                return; // Espera at√© que tempo suficiente tenha passado para o pr√≥ximo frame
            }
            lastTime = timestamp - (deltaTime % frameInterval); // Ajusta lastTime para manter a precis√£o

            // Limpa a tela do canvas (o fundo do body permanece)
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Desenha elementos de fundo espec√≠ficos do n√≠vel
            updateAndDrawBackgroundElements();

            checkLevelTransition();

            if (transitionActive) {
                drawTransition();
            } else {
                // L√≥gica para criar e atualizar guarda-chuvas
                const levelData = levels[currentLevelIndex];
                if (Math.random() < levelData.spawnRate + (score / 300000)) { // Ajustado spawn rate
                    createUmbrella();
                }

                for (let i = currentUmbrellas.length - 1; i >= 0; i--) {
                    const u = currentUmbrellas[i];
                    u.y += u.speed;
                    drawUmbrella(u); // Sempre usa a nova fun√ß√£o de desenho do guarda-chuva

                    if (u.y > canvas.height + u.height) { // Guarda-chuva saiu da tela
                        currentUmbrellas.splice(i, 1);
                        lives--;
                        sounds.loseLife.play();
                        livesElement.textContent = lives;
                        if (lives <= 0) {
                            endGame(false);
                            return; // Encerra a fun√ß√£o para evitar processamento desnecess√°rio
                        }
                    }
                }
            }

            // Atualizar e desenhar part√≠culas (efeitos de estouro)
            updateParticles();
            // Atualizar e desenhar textos flutuantes
            updateFloatingTexts();

            scoreElement.textContent = score;
        }

        // ===== CONTROLES DE TOQUE/CLIQUE =====
        function isClickInsideUmbrella(x, y, u) {
            // A √°rea de clique do guarda-chuva √© expandida ou contra√≠da pela sensibilidade
            // hitZoneModifier positivo para aumentar a √°rea, negativo para diminuir
            const hitZoneModifier = (1 - touchSensitivity) * 30; // 30 √© um valor de ajuste
            const effectiveX = u.x - hitZoneModifier / 2;
            const effectiveY = u.y - hitZoneModifier / 2;
            const effectiveWidth = u.width + hitZoneModifier;
            const effectiveHeight = u.height + hitZoneModifier;

            return (
                x >= effectiveX && x <= effectiveX + effectiveWidth &&
                y >= effectiveY && y <= effectiveY + effectiveHeight
            );
        }

        function handleClick(x, y) {
            if (!gameActive || transitionActive || isPaused) return;

            const levelData = levels[currentLevelIndex];

            for (let i = currentUmbrellas.length - 1; i >= 0; i--) {
                const u = currentUmbrellas[i];
                if (isClickInsideUmbrella(x, y, u)) {
                    soundPool.playPop(); // NOVO: Usa o pool de sons
                    vibratePhone(); // NOVO: Vibra o telefone

                    // Adiciona a pontua√ß√£o ao score total
                    score += levelData.scoreValue;
                    scoreElement.textContent = score;

                    // Cria o texto flutuante
                    createFloatingText(`+${levelData.scoreValue}`, u.x + u.width / 2, u.y + u.height / 2);

                    // Cria part√≠culas no local do estouro com base no n√≠vel
                    let particleColor = u.color; // Cor base do guarda-chuva
                    if (levelData.name.includes('Deserto')) particleColor = '#FFD700'; // Areia
                    else if (levelData.name.includes('Gelo')) particleColor = '#F0F8FF'; // Floco de neve
                    else if (levelData.name.includes('Espa√ßo')) particleColor = '#00ffff'; // Brilho espacial

                    createParticles(u.x + u.width/2, u.y + u.height/2, particleColor, 25);

                    currentUmbrellas.splice(i, 1);
                    break;
                }
            }
        }

        // Fun√ß√£o para criar part√≠culas de efeito (explos√£o)
        function createParticles(x, y, color, count = 15) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 4;

                currentParticles.push({
                    x: x,
                    y: y,
                    radius: 3 + Math.random() * 5,
                    color: color,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 2, // Levemente para cima no in√≠cio
                    life: 50 + Math.random() * 50
                });
            }
        }

        // Fun√ß√£o para atualizar e desenhar part√≠culas
        function updateParticles() {
            for (let i = currentParticles.length - 1; i >= 0; i--) {
                const p = currentParticles[i];

                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.05; // Gravidade
                p.life--;

                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 100;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();

                if (p.life <= 0) {
                    currentParticles.splice(i, 1);
                }
            }
            ctx.globalAlpha = 1; // Resetar alpha
        }

        // Nova fun√ß√£o para criar texto flutuante
        function createFloatingText(text, x, y) {
            floatingTexts.push({
                text: text,
                x: x,
                y: y,
                alpha: 1.0,
                vy: -1, // Sobe 1 pixel por frame
                life: 60 // Dura 60 frames (1 segundo a 60fps)
            });
        }

        // Nova fun√ß√£o para atualizar e desenhar textos flutuantes
        function updateFloatingTexts() {
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                const textObj = floatingTexts[i];
                textObj.y += textObj.vy;
                textObj.alpha -= 1.0 / textObj.life; // Diminui a opacidade ao longo da vida

                ctx.save();
                ctx.globalAlpha = Math.max(0, textObj.alpha); // Garante que a opacidade n√£o seja negativa
                ctx.fillStyle = 'white';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = 'black';
                ctx.shadowBlur = 5;
                ctx.fillText(textObj.text, textObj.x, textObj.y);
                ctx.restore();

                textObj.life--;
                if (textObj.life <= 0) {
                    floatingTexts.splice(i, 1);
                }
            }
        }

        // Fun√ß√£o para melhorar a detec√ß√£o de toque
        function getTouchPos(canvasDom, touchEvent) {
            const rect = canvasDom.getBoundingClientRect();
            return {
                x: touchEvent.touches[0].clientX - rect.left,
                y: touchEvent.touches[0].clientY - rect.top
            };
        }

        // Eventos de clique/toque (para o canvas do jogo)
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            handleClick(e.clientX - rect.left, e.clientY - rect.top);
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touchPos = getTouchPos(canvas, e);
            handleClick(touchPos.x, touchPos.y);
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });

        // Event Listeners para bot√µes de navega√ß√£o e controle do jogo
        restartBtn.addEventListener('click', () => {
            sounds.uiClick.play().catch(e => console.log("Erro ao tocar UI click:", e));
            resetGame();
        });
        playAgainWinBtn.addEventListener('click', () => {
            sounds.uiClick.play().catch(e => console.log("Erro ao tocar UI click:", e));
            resetGame();
        });
        pauseBtn.addEventListener('click', togglePause);
        resumeBtn.addEventListener('click', togglePause);
        backToStartBtn.addEventListener('click', () => {
            sounds.uiClick.play().catch(e => console.log("Erro ao tocar UI click:", e));
            returnToStartScreen();
        });

        // Event Listeners da Tela Inicial e Configura√ß√µes
        startButton.addEventListener('click', () => {
            sounds.uiClick.play().catch(e => console.log("Erro ao tocar UI click:", e));
            startScreen.classList.remove('active'); // NOVO: Remove active para transi√ß√£o
            startScreen.addEventListener('transitionend', function handler() {
                startScreen.style.display = 'none';
                startScreen.removeEventListener('transitionend', handler);
                resetGame(); // Inicia o jogo
            });
        });

        settingsButton.addEventListener('click', () => {
            sounds.uiClick.play().catch(e => console.log("Erro ao tocar UI click:", e));
            startScreen.classList.remove('active'); // NOVO: Remove active para transi√ß√£o
            startScreen.addEventListener('transitionend', function handler() {
                startScreen.style.display = 'none';
                startScreen.removeEventListener('transitionend', handler);
                settingsScreen.style.display = 'flex';
                setTimeout(() => settingsScreen.classList.add('active'), 10); // NOVO: Transi√ß√£o
                applyMenuBackground(); // Garante o fundo de menu nas configura√ß√µes
                updateSettingsUI(); // Atualiza os elementos da UI de configura√ß√µes
            });
        });

        settingsBackBtn.addEventListener('click', () => {
            sounds.uiClick.play().catch(e => console.log("Erro ao tocar UI click:", e));
            settingsScreen.classList.remove('active'); // NOVO: Remove active para transi√ß√£o
            settingsScreen.addEventListener('transitionend', function handler() {
                settingsScreen.style.display = 'none';
                settingsScreen.removeEventListener('transitionend', handler);
                startScreen.style.display = 'flex';
                setTimeout(() => startScreen.classList.add('active'), 10); // NOVO: Transi√ß√£o
                applyMenuBackground(); // Volta para o fundo do menu principal
            });
        });

        // ===== L√≥gica da Tela de Configura√ß√µes =====
        function updateSettingsUI() {
            touchSensitivitySlider.value = touchSensitivity;
            sensitivityValueSpan.textContent = touchSensitivity.toFixed(1);
            updateColorSwatchSelection();
        }

        function updateColorSwatchSelection() {
            colorSwatches.forEach(swatch => {
                swatch.classList.remove('selected');
                if (swatch.dataset.color === currentBackgroundPreset) {
                    swatch.classList.add('selected');
                }
            });
        }

        colorSwatches.forEach(swatch => {
            swatch.addEventListener('click', () => {
                sounds.uiClick.play().catch(e => console.log("Erro ao tocar UI click:", e));
                const colorPreset = swatch.dataset.color;
                currentBackgroundPreset = colorPreset;
                localStorage.setItem('backgroundPreset', currentBackgroundPreset);
                applyMenuBackground(); // Aplica o novo fundo ao menu de configura√ß√µes
                updateColorSwatchSelection();
            });
        });

        touchSensitivitySlider.addEventListener('input', (e) => {
            touchSensitivity = parseFloat(e.target.value);
            localStorage.setItem('touchSensitivity', touchSensitivity);
            sensitivityValueSpan.textContent = touchSensitivity.toFixed(1);
        });

        // ===== INICIALIZA√á√ÉO DO JOGO =====
        function initGameOnLoad() {
            highscoreElement.textContent = highscore;
            pauseBtn.style.display = 'none'; // Garante que o bot√£o de pausa n√£o apare√ßa na tela inicial

            // Aplica as configura√ß√µes salvas (fundo e sensibilidade) e mostra a tela inicial
            applyMenuBackground(); // Usa o preset salvo para a tela inicial
            touchSensitivitySlider.value = touchSensitivity;
            sensitivityValueSpan.textContent = touchSensitivity.toFixed(1);
            
            // NOVO: Esconde a splash screen e mostra a tela inicial ap√≥s um pequeno delay
            setTimeout(() => {
                splashScreen.classList.add('hidden');
                splashScreen.addEventListener('transitionend', function handler() {
                    splashScreen.style.display = 'none';
                    startScreen.style.display = 'flex';
                    setTimeout(() => startScreen.classList.add('active'), 10); // Ativa a transi√ß√£o
                    splashScreen.removeEventListener('transitionend', handler);
                });
            }, 1500); // 1.5 segundos de splash screen
        }

        // NOVO: Executa a inicializa√ß√£o ap√≥s o carregamento completo da p√°gina
        window.addEventListener('load', initGameOnLoad);
    </script>
</body>
</html>
